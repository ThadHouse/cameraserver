ext.useWpiUtil = { project ->
    project.tasks.create(name: "downloadWpiUtil") {
        description = 'Downloads the wpiutil maven dependency.'
        group = 'WPILib'
        def depFolder = "${project.buildDir}/dependencies"
        def utilZip = file("${depFolder}/wpiutil.zip")
        outputs.file(utilZip)
        def wpiUtil

        doFirst {
            def wpiUtilDependency = project.dependencies.create("edu.wpi.first.wpilib:wpiutil:+:${project.isArm ? 'arm' : 'desktop'}@zip")
            def wpiUtilConfig = project.configurations.detachedConfiguration(wpiUtilDependency)
            wpiUtilConfig.setTransitive(false)
            wpiUtil = wpiUtilConfig.files[0].canonicalFile
        }

        doLast {
            copy {
                from wpiUtil
                rename 'wpiutil(.+)', 'wpiutil.zip'
                into depFolder
            }
        }
    }

    def wpiUtilUnzipLocation = "${project.buildDir}/wpiutil"

    // Create a task that will unzip the wpiutil files into a temporary build directory
    project.tasks.create(name: "unzipWpiUtil", type: Copy) {
        description = 'Unzips the wpiutil maven dependency so that the include files and libraries can be used'
        group = 'WPILib'
        dependsOn project.tasks.downloadWpiUtil
        from zipTree(project.tasks.downloadWpiUtil.outputs.files.singleFile)
        into wpiUtilUnzipLocation
    }

    project.ext.wpiUtil = wpiUtilUnzipLocation
    project.ext.wpiUtilInclude = "$wpiUtilUnzipLocation/include"

    project.ext.addWpiUtilStaticLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project.tasks.unzipWpiUtil
        String path = project.getPlatformPath2(targetPlatform)
        if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.wpiUtil}/${path}/wpiutil.lib"
        } else {
            linker.args "${project.wpiUtil}/${path}/libwpiutil.a"
        }
    }
    
    project.ext.addWpiUtilSharedLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project.tasks.unzipWpiUtil
        String path = project.getPlatformPath2(targetPlatform)
        if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.wpiUtil}/${path}/wpiutil.dll"
        } else {
            linker.args "${project.wpiUtil}/${path}/libwpiutil.so"
        }
    }
}

ext.useNetworkTables = { project -> 
    project.tasks.create(name: "downloadNetworkTables") {
        description == 'Downloads the networktables maven dependency.'
        group = 'WPILib'
        def depFolder = "${project.buildDir}/dependencies"
        def ntZip = file("${depFolder}/NetworkTables.zip")
        outputs.file(ntZip)
        def networkTables
        
        doFirst {
            def ntDependency = project.dependencies.create("edu.wpi.first.wpilib.networktables.cpp:NetworkTables:+:${project.isArm ? 'arm' : 'desktop'}@zip")
            def ntConfig = project.configurations.detachedConfiguration(ntDependency)
            ntConfig.setTransitive(false)
            networkTables = ntConfig.files[0].canonicalFile
        }

        doLast {
            copy {
                from networkTables
                rename 'NetworkTables(.+)', 'NetworkTables.zip'
                into depFolder
            }
        }
    }
    
    def networkTablesUnzipLocation = "${project.buildDir}/networktables"

    // Create a task that will unzip the networktables files into a temporary build directory
    project.tasks.create(name: "unzipNetworkTable", type: Copy) {
        description = 'Unzips the networktables maven dependency so that the include files and libraries can be used'
        group = 'WPILib'
        dependsOn project.tasks.downloadNetworkTables
        from zipTree(project.tasks.downloadNetworkTables.outputs.files.singleFile)
        into networkTablesUnzipLocation
    }

    project.ext.networkTables = networkTablesUnzipLocation
    project.ext.networkTablesInclude = "$networkTablesUnzipLocation/include"

    project.ext.addNetworkTablesStaticLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project.tasks.unzipNetworkTable
        String path = project.getPlatformPath2(targetPlatform)
        if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.networkTables}/${path}/networktables.lib"
        } else {
            linker.args "${project.networkTables}/${path}/libnetworktables.a"
        }
    }
    
    project.ext.addNetworkTablesSharedLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn project.tasks.unzipNetworkTable
        String path = project.getPlatformPath2(targetPlatform)
        if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.networkTables}/${path}/networktables.dll"
        } else {
            linker.args "${project.networkTables}/${path}/libnetworktables.so"
        }
    }
}

ext.useWpiLib = { project -> 
    if (project.isArm) {
        project.tasks.create(name: "downloadWPILib") {
            description == 'Downloads the wpilibc maven dependency.'
            group = 'WPILib'
            def depFolder = "${project.buildDir}/dependencies"
            def wpilibZip = file("${depFolder}/athena-wpilib.zip")
            outputs.file(wpilibZip)
            def wpilib
            
            doFirst {
                def wpiLibDependency = project.dependencies.create("edu.wpi.first.wpilibc:athena:2017.+@zip")
                def wpiLibConfig = project.configurations.detachedConfiguration(wpiLibDependency)
                wpiLibConfig.setTransitive(false)
                wpilib = wpiLibConfig.files[0].canonicalFile
            }

            doLast {
                copy {
                    from wpilib
                    rename 'athena(.+)', 'athena-wpilib.zip'
                    into depFolder
                }
            }
        }
        
        project.tasks.create(name: "downloadHal") {
            description == 'Downloads the hal maven dependency.'
            group = 'WPILib'
            def depFolder = "${project.buildDir}/dependencies"
            def halZip = file("${depFolder}/hal.zip")
            outputs.file(halZip)
            def hal
            
            doFirst {
                def halDependency = project.dependencies.create("edu.wpi.first.wpilib:hal:2017.+@zip")
                def halConfig = project.configurations.detachedConfiguration(halDependency)
                halConfig.setTransitive(false)
                hal = halConfig.files[0].canonicalFile
            }

            doLast {
                copy {
                    from hal
                    rename 'hal(.+)', 'hal.zip'
                    into depFolder
                }
            }
        }
        
        def wpiLibUnzipLocation = "${project.buildDir}/wpilibc"
        def halUnzipLocation = "${project.buildDir}/hal"

        // Create a task that will unzip the wpilib files into a temporary build directory
        project.tasks.create(name: "unzipWpiLib", type: Copy) {
            description = 'Unzips the wpilibc maven dependency so that the include files and libraries can be used'
            group = 'WPILib'
            dependsOn project.tasks.downloadWPILib
            from zipTree(project.tasks.downloadWPILib.outputs.files.singleFile)
            into wpiLibUnzipLocation
        }
        
        // Create a task that will unzip the hal files into a temporary build directory
        project.tasks.create(name: "unzipHal", type: Copy) {
            description = 'Unzips the hal maven dependency so that the include files and libraries can be used'
            group = 'WPILib'
            dependsOn project.tasks.downloadHal
            from zipTree(project.tasks.downloadHal.outputs.files.singleFile)
            into halUnzipLocation
        }        

        project.ext.wpiLib = wpiLibUnzipLocation
        project.ext.wpiLibInclude = "$wpiLibUnzipLocation/include"
        
        project.ext.hal = halUnzipLocation
        project.ext.halInclude = "$halUnzipLocation/include"

        project.ext.addWpiLibLibraryLinks = { compileTask, linker, targetPlatform ->
            compileTask.dependsOn project.tasks.unzipWpiLib
            compileTask.dependsOn project.tasks.unzipHal
            
            linker.args "{project.hal}/libHALAthena.so"
            linker.args "{project.hal}/libnilibraries.so"
            linker.args "${project.wpiLib}/libwpilibc.so"
            linker.args << '-L' + halUnzipLocation
            linker.args << '-L' + wpiLibUnzipLocation
        }
    }
}
ext.getOpenCvPlatformPackage = { targetPlatform ->
    if (targetPlatform.architecture.arm) {
        return 'linux-arm'
    } else if (targetPlatform.operatingSystem.linux) {
        if (targetPlatform.architecture.amd64) {
            return 'linux-x86_64'
        } else {
            return 'linux-' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.windows) {
        if (targetPlatform.architecture.amd64) {
            return 'windows-x86_64'
        } else {
            return 'windows-' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.macOsX) {
        if (targetPlatform.architecture.amd64) {
            return 'osx-x86_64'
        } else {
            return 'osx-' + targetPlatform.architecture.name
        }
    } else {
        return targetPlatform.operatingSystem.name + '-' + targetPlatform.architecture.name
    }
}

task downloadOpenCvHeaders() {
    description = 'Downloads the OpenCV Headers maven dependency.'
    group = 'WPILib'
    def depFolder = "${buildDir}/dependencies"
    def openCvHeadersZip = file("${depFolder}/opencv-headers.zip")
    outputs.file(openCvHeadersZip)
    def openCvHeaders

    doFirst {
        def openCvHeadersDependency = project.dependencies.create("org.opencv:opencv-headers:3.1.0@jar")
        def openCvHeadersConfig = project.configurations.detachedConfiguration(openCvHeadersDependency)
        openCvHeadersConfig.setTransitive(false)
        openCvHeaders = openCvHeadersConfig.files[0].canonicalFile
    }

    doLast {
        copy {
            from openCvHeaders
            rename 'opencv-headers(.+)', 'opencv-headers.zip'
            into depFolder
        }
    }
}

ext.useOpenCv = { project ->
    def openCvUnzipLocation = "${project.buildDir}/opencv"

    project.tasks.create(name: "unzipOpenCvHeaders", type: Copy) {
        description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
        group = 'OpenCv'
        dependsOn downloadOpenCvHeaders
        from zipTree(downloadOpenCvHeaders.outputs.files.singleFile)
        into "${openCvUnzipLocation}/include"
    }

    project.ext.openCv = openCvUnzipLocation
    project.ext.openCvInclude = "$openCvUnzipLocation/include"

    project.ext.addOpenCvLibraryLinks = { compileTask, linker, targetPlatform ->
        def openCvPlatform = project.getOpenCvPlatformPackage(targetPlatform)
        def openCvNativesFolder = "${project.openCv}/${openCvPlatform}"

        if (project.tasks.findByPath("unzipOpenCvNatives_${openCvPlatform}") == null) {
            project.tasks.create(name: "downloadOpenCvNatives_${openCvPlatform}") {
                description = 'Downloads the OpenCV natives maven dependency.'
                group = 'OpenCv'
                def depFolder = "${project.buildDir}/dependencies"
                def openCvNativesZip = file("${depFolder}/opencv-natives-${openCvPlatform}.zip")
                outputs.file(openCvNativesZip)
                def openCvNatives

                doFirst {
                    def openCvNativesDependency = project.dependencies.create("org.opencv:opencv-natives:3.1.0:${openCvPlatform}@jar")
                    def openCvNativesConfig = project.configurations.detachedConfiguration(openCvNativesDependency)
                    openCvNativesConfig.setTransitive(false)
                    openCvNatives = openCvNativesConfig.files[0].canonicalFile
                }

                doLast {
                    copy {
                        from openCvNatives
                        rename 'opencv-natives(.+)', "opencv-natives-${openCvPlatform}.zip"
                        into depFolder
                    }
                }
            }

            project.tasks.create(name: "unzipOpenCvNatives_${openCvPlatform}", type: Copy) {
                description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
                group = 'OpenCv'
                dependsOn "downloadOpenCvNatives_${openCvPlatform}"
                from zipTree(project.tasks["downloadOpenCvNatives_${openCvPlatform}"].outputs.files.singleFile)
                into openCvNativesFolder
                exclude '**/MANIFEST.MF'
            }
        }

        if (project.includeJava && project.tasks.findByPath("unzipOpenCvJni_${openCvPlatform}") == null) {
            project.tasks.create(name: "downloadOpenCvJni_${openCvPlatform}") {
                description = 'Downloads the OpenCV JNI maven dependency.'
                group = 'OpenCv'
                def depFolder = "${project.buildDir}/dependencies"
                def openCvJniZip = file("${depFolder}/opencv-jni-${openCvPlatform}.zip")
                outputs.file(openCvJniZip)
                def openCvJni

                doFirst {
                    def openCvJniDependency = project.dependencies.create("org.opencv:opencv-jni:3.1.0:${openCvPlatform}@jar")
                    def openCvJniConfig = project.configurations.detachedConfiguration(openCvJniDependency)
                    openCvJniConfig.setTransitive(false)
                    openCvJni = openCvJniConfig.files[0].canonicalFile
                }

                doLast {
                    copy {
                        from openCvJni
                        rename 'opencv-jni(.+)', "opencv-jni-${openCvPlatform}.zip"
                        into depFolder
                    }
                }
            }

            project.tasks.create(name: "unzipOpenCvJni_${openCvPlatform}", type: Copy) {
                description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
                group = 'OpenCv'
                dependsOn "downloadOpenCvJni_${openCvPlatform}"
                from zipTree(project.tasks["downloadOpenCvJni_${openCvPlatform}"].outputs.files.singleFile)
                into openCvNativesFolder
                exclude '**/MANIFEST.MF'
            }
        }

        compileTask.dependsOn "unzipOpenCvHeaders", "unzipOpenCvNatives_${openCvPlatform}"
        if (project.includeJava) {
            compileTask.dependsOn "unzipOpenCvJni_${openCvPlatform}"
        }
        if (targetPlatform.architecture.arm) {
            linker.args "${openCvNativesFolder}/libopencv_calib3d.so"
            linker.args "${openCvNativesFolder}/libopencv_features2d.so"
            linker.args "${openCvNativesFolder}/libopencv_flann.so"
            linker.args "${openCvNativesFolder}/libopencv_highgui.so"
            linker.args "${openCvNativesFolder}/libopencv_imgcodecs.so"
            linker.args "${openCvNativesFolder}/libopencv_imgproc.so"
            linker.args "${openCvNativesFolder}/libopencv_ml.so"
            linker.args "${openCvNativesFolder}/libopencv_objdetect.so"
            linker.args "${openCvNativesFolder}/libopencv_photo.so"
            linker.args "${openCvNativesFolder}/libopencv_shape.so"
            linker.args "${openCvNativesFolder}/libopencv_stitching.so"
            linker.args "${openCvNativesFolder}/libopencv_superres.so"
            linker.args "${openCvNativesFolder}/libopencv_video.so"
            linker.args "${openCvNativesFolder}/libopencv_videoio.so"
            linker.args "${openCvNativesFolder}/libopencv_videostab.so"
            linker.args "${openCvNativesFolder}/libopencv_core.so"
            linker.args "-ldl"
            linker.args "-lz"
        } else if (targetPlatform.operatingSystem.windows) {
            linker.args "${openCvNativesFolder}/opencv_core.lib"
        } else {
            linker.args "${openCvNativesFolder}/libopencv_calib3d.a"
            linker.args "${openCvNativesFolder}/libopencv_features2d.a"
            linker.args "${openCvNativesFolder}/libopencv_flann.a"
            linker.args "${openCvNativesFolder}/libopencv_highgui.a"
            linker.args "${openCvNativesFolder}/libopencv_imgcodecs.a"
            linker.args "${openCvNativesFolder}/libopencv_imgproc.a"
            linker.args "${openCvNativesFolder}/libopencv_ml.a"
            linker.args "${openCvNativesFolder}/libopencv_objdetect.a"
            linker.args "${openCvNativesFolder}/libopencv_photo.a"
            linker.args "${openCvNativesFolder}/libopencv_shape.a"
            linker.args "${openCvNativesFolder}/libopencv_stitching.a"
            linker.args "${openCvNativesFolder}/libopencv_superres.a"
            linker.args "${openCvNativesFolder}/libopencv_video.a"
            linker.args "${openCvNativesFolder}/libopencv_videoio.a"
            linker.args "${openCvNativesFolder}/libopencv_videostab.a"
            linker.args "${openCvNativesFolder}/libopencv_core.a"
            linker.args "${openCvNativesFolder}/liblibjpeg.a"
            linker.args "${openCvNativesFolder}/liblibpng.a"
            linker.args "-ldl"
            linker.args "-lz"
        }
    }
}
